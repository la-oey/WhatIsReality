---
title: "ABM"
author: "Lauren Oey"
date: "2/24/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(cowplot)
library(extraDistr)
library(colorspace)
library(MASS)
library(RColorBrewer)
library(scales)
```

## Variables

```{r}
softmax.param = 40
# ns = seq(0,100,2)
ns = seq(0,1,0.02)
n = length(ns)
```

## General Functions

k, ksay, kest are all scaled between 0 and 1

```{r}
logitToProb <- function(logit){
  exp(logit) / (1+exp(logit))
}

probToLogit <- function(prob){
  log(prob / (1 - prob))
}

softmax <- function(alph, allEV) { ## allEV = vector of numerics
  aev = exp(alph * allEV)
  return(aev/sum(aev))
}
```

### Figure Generator
```{r}
fig <- function(mat, labx="", laby="", title="", role, leg.position="none") {
  roleColor = ifelse(role=="sender", "forestgreen", "brown")
  mat %>%
    as_tibble() %>%
    mutate(ky = ns) %>%
    pivot_longer(-ky, names_to = 'kx', values_to='probability') %>%
    mutate(kx = (as.numeric(substr(kx, 2, (n-1)))-1) / (n-1)) %>%
    ggplot(aes(x=kx, y=ky, fill=probability)) +
    geom_tile(size=0.5) +
    ggtitle(title) +
    scale_x_continuous(labx, expand=c(0,0), breaks=seq(0,1,0.5)) +
    scale_y_continuous(laby, expand=c(0,0), breaks=seq(0,1,0.5)) +
    scale_fill_gradient2(low="white", mid="turquoise4", high="midnightblue", midpoint=0.5,
                       limits=c(0,1), labels=c("0%","25%","50%","75%","100%")) +
    theme(axis.line = element_line(colour = roleColor),
          panel.background = element_rect(fill = "white"),
          legend.position=leg.position)
}
```

### Utility
```{r}
# sender's utility
u.S <- function(ksay, k, kest, 
  a, alph,
  m, mu){ #coop
  rw = kest - k
  mw = ksay - k
  # preserves sign when alph is even
  #rw.pow = ifelse(alph %% 2 == 0 & rw < 0 & !coop, -(rw^alph), rw^alph) 
  
  #a * rw.pow + m * abs(mw)^mu
  a * rw^alph + m * abs(mw)^mu
}


# ns2 = 0:10
# n2 = length(ns2)
# round(
#   array(
#     u.S(rep(ns2, n2*n2), rep(rep(ns2,each=n2), n2), rep(ns2,each=n2*n2),
#         1,
#         1,
#         -1,
#         0.5),
#     dim=c(n2,n2,n2)),
#   2) #x(rows) = ksay, y(cols) = k, z(lists) = kest

# receiver's utility
u.R <- function(k, kest){
  -(kest - k)^2
}

# matrix(u.R(rep(ns2, n2), rep(ns2,each=n2)), nrow=n2)
```





```{r}
## Receiver0 P(kest|ksay)
r.0 <- function() {
  diag(n)
}

## Sender P(ksay|k)
# to run with even alph, need to preserve sign (coop Boolean)
sender = function(a, alph, m, mu,
                  p.R.kest_ksay){ #x(rows) = ksay, y(cols) = k, z(list) = kest
  arr.pR <- aperm(array(rep(p.R.kest_ksay, each=n), dim=c(n,n,n)), c(3,1,2))
  arr.uS <- array(
    u.S(ns, 
        rep(rep(ns, each=n), n), 
        rep(ns, each=n*n),
        a, alph, m, mu), 
    dim=c(n,n,n))
  EV = apply(arr.uS * arr.pR, MARGIN=c(1,2), FUN=sum)
  apply(EV, MARGIN=2, softmax, softmax.param) # listsums -> 2D arr, x(rows) = ksay, y(cols) = k
}

## Receiver P(kest|ksay)
receiver = function(p.S.ksay_k){ #x(rows) = ksay, y(cols) = k, z(list) = kest
  p.S.k_ksay <- p.S.ksay_k / rowSums(p.S.ksay_k) # p(k | ksay)
  arr.pS <- array(rep(p.S.k_ksay, n), dim=c(n,n,n))
  arr.uR <- array(rep(mapply(function(i) u.R(i, ns), ns), each=n), dim=c(n,n,n))
  EV.R = t(apply(arr.uR * arr.pS, MARGIN=c(1,3), FUN=sum))
  apply(EV.R, MARGIN=2, softmax, softmax.param) # rowsums -> 2D arr, x(rows) = kest, y(cols) = ksay
}
```

kest | k

```{r}
## Receiver inference about truth P(kest|k)
receiver.k = function(p.S.ksay_k){ #x(rows) = ksay, y(cols) = k, z(list) = kest
  p.S.k_ksay <- p.S.ksay_k / rowSums(p.S.ksay_k) # p(k | ksay)
  arr.pS <- array(rep(p.S.k_ksay, n), dim=c(n,n,n))
  arr.uR <- array(rep(mapply(function(i) u.R(i, ns), ns), each=n), dim=c(n,n,n))
  EV.R = t(apply(arr.uR * arr.pS, MARGIN=c(2,3), FUN=sum)) # marginalizes over ksay
  apply(EV.R, MARGIN=2, softmax, softmax.param) # rowsums -> 2D arr, x(rows) = kest, y(cols) = k
}
```


```{r ignore=TRUE}
ns1 = seq(0,0.4,0.1) #sums to 1
n1 = length(ns1)
# receiver's behavior
# x(rows) = kest
# y(cols) = ksay
# validation: cols sum to 1
(test.r.0 = array(rep(ns1, n1), dim=c(n1,n1)))
# ------------->
# x(rows) = ksay
# y(cols) = k
# z(list) = kest
# validation: test.r.0 should be repeated across cols
(test.arr.pR = aperm(array(test.r.0, dim=c(n1,n1,n1)), c(3,1,2)))

# sender's utility
# x(rows) = ksay
# y(cols) = k
# z(list) = kest
test.a = 1
test.alph = 1
test.m = -1
test.mu = 2
# validation: cooperative sender (-1,2,0,0): cols == list ? value = 0
# validation: deceptive sender (1,1,-1,2)
(test.arr.uS <- array(
    u.S(ns1, 
        rep(rep(ns1, each=n1), n1), 
        rep(ns1, each=n1*n1),
        test.a, test.alph, test.m, test.mu), 
    dim=c(n1,n1,n1)))
# sums lists (kest)
(test.EV = apply(test.arr.uS * test.arr.pR, MARGIN=c(1,2), FUN=sum))
# apply softmax on columns
(test.p.S.ksay_k <- apply(test.EV, MARGIN=2, softmax, softmax.param))

#validation: cols sum to 1
colSums(test.p.S.ksay_k)
```

Verifying receiver function

```{r ignore=TRUE}
# sender's behavior
# x(rows) = ksay
# y(cols) = k
# validation: cols sum to 1
test.p.S.ksay_k

# p(k | ksay)
(test.p.S.k_ksay <- test.p.S.ksay_k / rowSums(test.p.S.ksay_k)) 

# ------------->
# x(rows) = ksay
# y(cols) = k
# z(list) = kest
# validation: test.p.S.k_ksay should be repeated across lists
(test.arr.pS <- array(rep(test.p.S.k_ksay, n1), dim=c(n1,n1,n1)))
# receiver always wants accuracy
(test.arr.uR <- array(rep(mapply(function(i) u.R(i, ns1), ns1), each=n1), dim=c(n1,n1,n1)))

# sums columns (k)
# then transposes
(test.EV.R = t(apply(test.arr.uR * test.arr.pS, MARGIN=c(1,3), FUN=sum)))
# apply softmax on columns
(test.p.R.kest_ksay = apply(test.EV.R, MARGIN=2, softmax, softmax.param))

#validation: cols sum to 1
colSums(test.p.R.kest_ksay)
```

# 1. Do deceptive senders and receivers reach an equilibrium? Or do they continue ratcheting to more extreme messages?

```{r warning=FALSE}
# p.r0 = r.0()
# sim.a = 1
# sim.alph = 1
# sim.m = -1 #0
# sim.mu = 2
# p.s1.defec.ksay_k = sender(sim.a, sim.alph, sim.m, sim.mu, p.r0)
# p.r1.kest_ksay = receiver(p.s1.defec.ksay_k)
# p.s2.defec.ksay_k = sender(sim.a, sim.alph, sim.m, sim.mu, p.r1.kest_ksay)
# p.r2.kest_ksay = receiver(p.s2.defec.ksay_k)
# p.s3.defec.ksay_k = sender(sim.a, sim.alph, sim.m, sim.mu, p.r2.kest_ksay)
# p.r3.kest_ksay = receiver(p.s3.defec.ksay_k)
# p.s4.defec.ksay_k = sender(sim.a, sim.alph, sim.m, sim.mu, p.r3.kest_ksay)
# p.r4.kest_ksay = receiver(p.s4.defec.ksay_k)
# p.s5.defec.ksay_k = sender(sim.a, sim.alph, sim.m, sim.mu, p.r4.kest_ksay)
# p.r5.kest_ksay = receiver(p.s5.defec.ksay_k)
# p.s6.defec.ksay_k = sender(sim.a, sim.alph, sim.m, sim.mu, p.r5.kest_ksay)
# 
# 
# blank <- ggplot() + theme_minimal()
# fig.r0 <- fig(p.r0, "ksay", "kest", "Receiver L0") 
# legend <- get_legend(fig.r0)
# fig.s1 <- fig(p.s1.defec.ksay_k, "k", "ksay", "Sender L1 Deceptive") + theme(legend.position="none")
# fig.r1 <- fig(p.r1.kest_ksay, "ksay", "kest", "Receiver L1") + theme(legend.position="none")
# fig.s2 <- fig(p.s2.defec.ksay_k, "k", "ksay", "Sender L2 Deceptive") + theme(legend.position="none")
# fig.r2 <- fig(p.r2.kest_ksay, "ksay", "kest", "Receiver L2") + theme(legend.position="none")
# fig.s3 <- fig(p.s3.defec.ksay_k, "k", "ksay", "Sender L3 Deceptive") + theme(legend.position="none")
# fig.r3 <- fig(p.r3.kest_ksay, "ksay", "kest", "Receiver L3") + theme(legend.position="none")
# fig.s4 <- fig(p.s4.defec.ksay_k, "k", "ksay", "Sender L4 Deceptive") + theme(legend.position="none")
# fig.r4 <- fig(p.r4.kest_ksay, "ksay", "kest", "Receiver L4") + theme(legend.position="none")
# fig.s5 <- fig(p.s5.defec.ksay_k, "k", "ksay", "Sender L5 Deceptive") + theme(legend.position="none")
# fig.r5 <- fig(p.r5.kest_ksay, "ksay", "kest", "Receiver L5") + theme(legend.position="none")
# fig.s6 <- fig(p.s6.defec.ksay_k, "k", "ksay", "Sender L6 Deceptive") + theme(legend.position="none")
# plot_grid(blank,fig.r0 + theme(legend.position="none"), 
#           fig.s1, fig.r1, fig.s2, fig.r2, fig.s3, fig.r3, fig.s4, fig.r4, fig.s5, fig.r5, fig.s6, legend,
#           nrow=2, byrow = FALSE)
# ggsave("img/model.full_defec.png", width=13, height=4)
```

Receiver kest | k

```{r}
softmax.param = 30
sim.a = 1
sim.alph = 1
sim.m = -1 #0
sim.mu = 2

p.r0 = r.0()
p.s1.defec.ksay_k = sender(sim.a, sim.alph, sim.m, sim.mu, p.r0)
p.r1.kest_ksay = receiver(p.s1.defec.ksay_k)
p.r1.kest_k = receiver.k(p.s1.defec.ksay_k)
p.s2.defec.ksay_k = sender(sim.a, sim.alph, sim.m, sim.mu, p.r1.kest_ksay)
p.r2.kest_ksay = receiver(p.s2.defec.ksay_k)
p.r2.kest_k = receiver.k(p.s2.defec.ksay_k)
p.s3.defec.ksay_k = sender(sim.a, sim.alph, sim.m, sim.mu, p.r2.kest_ksay)
p.r3.kest_ksay = receiver(p.s3.defec.ksay_k)
p.r3.kest_k = receiver.k(p.s3.defec.ksay_k)
p.s4.defec.ksay_k = sender(sim.a, sim.alph, sim.m, sim.mu, p.r3.kest_ksay)
p.r4.kest_ksay = receiver(p.s4.defec.ksay_k)
p.r4.kest_k = receiver.k(p.s4.defec.ksay_k)
p.s5.defec.ksay_k = sender(sim.a, sim.alph, sim.m, sim.mu, p.r4.kest_ksay)

blank <- ggplot() + annotate("text", label="(b) Deceptive", x=1, y=1, size=6) + theme_void()
fig.r0 <- fig(p.r0, "ksay", "kest", "L0 Receiver", "receiver", "right") +
  theme(legend.direction="horizontal", 
        axis.line = element_line(linetype="dashed"))
legend <- get_legend(fig.r0)
fig.s1 <- fig(p.s1.defec.ksay_k, "k", "ksay", "L1 Sender", "sender")
fig.r1 <- fig(p.r1.kest_k, "k", "kest", role="receiver")
fig.s2 <- fig(p.s2.defec.ksay_k, title="L2", role="sender")
fig.r2 <- fig(p.r2.kest_k, role="receiver")
fig.s3 <- fig(p.s3.defec.ksay_k, title="L3", role="sender")
fig.r3 <- fig(p.r3.kest_k, role="receiver")
fig.s4 <- fig(p.s4.defec.ksay_k, title="L4", role="sender")
fig.r4 <- fig(p.r4.kest_k, role="receiver")
fig.s5 <- fig(p.s5.defec.ksay_k, title="L5", role="sender")

decep_levels <- plot_grid(blank,fig.r0 + theme(legend.position="none"), 
          fig.s1, fig.r1, fig.s2, fig.r2, fig.s3, fig.r3, fig.s4, fig.r4, fig.s5, 
          nrow=2, byrow = FALSE)
decep_levels
```


Cooperative sender and receiver inference

```{r}
sim.a = -1
sim.alph = 2
sim.m = 0
sim.mu = 0
#sim.coop = TRUE

p.r0 = r.0()
p.s1.coop.ksay_k = sender(sim.a, sim.alph, sim.m, sim.mu, p.r0)
p.r1.kest_ksay = receiver(p.s1.coop.ksay_k)
p.r1.kest_k = receiver.k(p.s1.coop.ksay_k)
p.s2.coop.ksay_k = sender(sim.a, sim.alph, sim.m, sim.mu, p.r1.kest_ksay)
p.r2.kest_ksay = receiver(p.s2.coop.ksay_k)
p.r2.kest_k = receiver.k(p.s2.coop.ksay_k)
p.s3.coop.ksay_k = sender(sim.a, sim.alph, sim.m, sim.mu, p.r2.kest_ksay)
p.r3.kest_ksay = receiver(p.s3.coop.ksay_k)
p.r3.kest_k = receiver.k(p.s3.coop.ksay_k)
p.s4.coop.ksay_k = sender(sim.a, sim.alph, sim.m, sim.mu, p.r3.kest_ksay)
p.r4.kest_ksay = receiver(p.s4.coop.ksay_k)
p.r4.kest_k = receiver.k(p.s4.coop.ksay_k)
p.s5.coop.ksay_k = sender(sim.a, sim.alph, sim.m, sim.mu, p.r4.kest_ksay)

blank <- ggplot() + annotate("text", label="(a) Cooperative", x=1, y=1, size=6) + theme_void()
fig.r0 <- fig(p.r0, "ksay", "kest", "L0 Receiver", "receiver") +
  theme(axis.line = element_line(linetype="dashed"))
# legend <- get_legend(fig.r0)
fig.s1 <- fig(p.s1.coop.ksay_k, "k", "ksay", "L1 Sender", role="sender")
fig.r1 <- fig(p.r1.kest_k, "k", "kest", role="receiver")
fig.s2 <- fig(p.s2.coop.ksay_k, title="L2", role="sender")
fig.r2 <- fig(p.r2.kest_k, role="receiver")
fig.s3 <- fig(p.s3.coop.ksay_k, title="L3", role="sender")
fig.r3 <- fig(p.r3.kest_k, role="receiver")
fig.s4 <- fig(p.s4.coop.ksay_k, title="L4", role="sender")
fig.r4 <- fig(p.r4.kest_k, role="receiver")
fig.s5 <- fig(p.s5.coop.ksay_k, title="L5", role="sender")

coop_levels <- plot_grid(blank,fig.r0,
          fig.s1, fig.r1, fig.s2, fig.r2, fig.s3, fig.r3, fig.s4, fig.r4, fig.s5, 
          nrow=2, byrow = FALSE)

plot_grid(coop_levels, decep_levels, legend, nrow=3, rel_heights=c(0.45,0.45,0.1))
ggsave("img/levels.pdf",height=8, width=10)
```



Behavior converges to equilibrium, so not using Poisson weighting...
Examine behavior of LN agent
```{r}
# depth is 0-indexed
agent.LN <- function(a, alph, m, mu, depth){
  store.s.ksay_k <- array(NA, dim=c(n,n,depth+1))
  store.r.kest_ksay <- array(NA, dim=c(n,n,depth+1))
  store.r.kest_k <- array(NA, dim=c(n,n,depth+1))
  p.r0 = r.0()
  store.s.ksay_k[,,1] = NA
  store.r.kest_ksay[,,1] = p.r0
  store.r.kest_k[,,1] = NA
  
  if(depth > 0){
    for(d in 2:(depth+1)){
      store.s.ksay_k[,,d] = sender(a, alph, m, mu, store.r.kest_ksay[,,d-1])
      store.r.kest_ksay[,,d] = receiver(store.s.ksay_k[,,d])
      store.r.kest_k[,,d] = receiver.k(store.s.ksay_k[,,d])
    }
  }
  
  # return last level of sender and receivers
  return(list(store.s.ksay_k[,,depth+1], # [[1]] returns depth-level sender
              store.r.kest_ksay[,,depth+1], # [[2]] returns depth-level receiver
              store.r.kest_k[,,depth+1])) # [[3]] returns depth-level receiver
}

agent.LN(1,1,-1,2,1) # 3rd level deceptive agent
agent.LN(-1,2,0,0,1) # 2nd level cooperative agent

fig(agent.LN(1,1,-1,2,5)[[3]], "k", "kest", "Receiver L5 Deceptive")
fig(agent.LN(1,3,-1,2,5)[[3]], "k", "kest", "Receiver L5 Deceptive")
fig(agent.LN(-1,2,0,0,2)[[1]], "k", "ksay", "Sender L2 Cooperative")
# Deceptive but no cost to bigger lies
# L1 says biggest lie
# L2 says uniform lies
fig(agent.LN(1,1,0,2,1)[[1]], "k", "ksay", "Sender L1 -> L2 Deceptive Edge Case") 



fig(agent.LN(1,1,-0.1,2,10)[[1]], "k", "ksay", "Sender L10 Deceptive", "sender")
fig(agent.LN(1,1,-0.1,2,10)[[2]], "ksay", "kest", "Receiver L10 Deceptive", "receiver")
fig(agent.LN(1,1,-0.1,2,10)[[3]], "k", "kest", "Receiver L10 Deceptive", "receiver")

am0.5 = agent.LN(1,1,-2,2,20)
am1 = agent.LN(1,1,-1,2,20)
am2.5 = agent.LN(1,1,-0.4,2,20)
am10 = agent.LN(1,1,-0.1,2,20)
am100 = agent.LN(1,1,-0.01,2,20)
am1000 = agent.LN(1,1,-0.001,2,20)
plot_grid(
  fig(am0.5[[1]], "k", "ksay", "a/m = 0.5", "sender"),
  fig(am0.5[[2]], "ksay", "kest", "", "receiver"),
  fig(am0.5[[3]], "k", "kest", "", "receiver"),
  fig(am1[[1]], "k", "ksay", "a/m = 1", "sender"),
  fig(am1[[2]], "ksay", "kest", "", "receiver"),
  fig(am1[[3]], "k", "kest", "", "receiver"),
  fig(am2.5[[1]], "k", "ksay", "a/m = 2.5", "sender"),
  fig(am2.5[[2]], "ksay", "kest", "", "receiver"),
  fig(am2.5[[3]], "k", "kest", "", "receiver"),
  fig(am10[[1]], "k", "ksay", "a/m = 10", "sender"),
  fig(am10[[2]], "ksay", "kest", "", "receiver"),
  fig(am10[[3]], "k", "kest", "", "receiver"),
  fig(am100[[1]], "k", "ksay", "a/m = 100", "sender"),
  fig(am100[[2]], "ksay", "kest", "", "receiver"),
  fig(am100[[3]], "k", "kest", "", "receiver"),
  ncol=3
)
ggsave("img/amsims.png",width=6,height=10)
```

# Measure variance of kest | k

```{r}
err.mat = -matrix(u.R(rep(ns, n), rep(ns,each=n)), nrow=n) #reusing receiver's L2 loss function w/ neg sign

# weighted variance of kest | k
eval.kest_k.wvar <- function(kest_k){
  sum(kest_k * err.mat) / sum(kest_k) # sum of denom should be 51
}

eval.kest_k.wvar(r.0())
eval.kest_k.wvar(agent.LN(1,1,-1,2,3)[[3]])
eval.kest_k.wvar(agent.LN(1,1,-1,2,20)[[3]])
eval.kest_k.wvar(agent.LN(10,1,-1,2,20)[[3]])
fig(agent.LN(10,1,-0.01,2,20)[[3]], role="receiver")
eval.kest_k.wvar(agent.LN(10,1,5,2,20)[[3]])
eval.kest_k.wvar(agent.LN(-1,2,0,0,5,FALSE)[[3]])
eval.kest_k.wvar(agent.LN(-1,2,0,0,5,TRUE)[[3]])
```

# Measure R^2 of kest | k

```{r}
eval.kest_k.rsq <- function(kest_k){
  scols = kest_k*bias.mat - colMeans(kest_k*bias.mat)
  srows = kest_k*bias.mat - rowMeans(kest_k*bias.mat)
  var.kest = sum(scols^2)
  var.k = sum(srows^2)
  sum(scols * srows)/sum(kest_k) / sqrt(var.kest * var.k)
}
eval.kest_k.rsq(agent.LN(1,1,-1,2,3)[[3]])

eval.kest_k.rsq.sim <- function(kest_k){
  uncountedProb.df <- kest_k %>%
    as_tibble() %>% 
    mutate(kest = ns) %>% 
    pivot_longer(-kest, names_to = 'k', values_to='probability') %>% 
    mutate(k = (as.numeric(substr(k, 2, 10))-1) * 0.02,
           probability = round(10000 * probability)) %>%
    rename(counts = probability) %>%
    uncount(weights = counts)
  cor(uncountedProb.df$kest, uncountedProb.df$k)
}

eval.kest_k.rsq.sim(agent.LN(1,1,-1,2,3)[[3]])
```

# Measure bias
```{r}
direc.err <- function(k1, k2){
  k1 - k2
}
bias.mat = matrix(direc.err(rep(ns, n), rep(ns,each=n)), nrow=n)
t(bias.mat)

eval.bias <- function(ktype){
  sum(ktype * bias.mat) / sum(ktype) # sum of denom should be 51
}

eval.bias(r.0())
eval.bias(agent.LN(1,1,-1,2,2)[[1]]) # decep sender's bias
eval.bias(agent.LN(1,1,-1,2,5)[[2]]) # decep receiver's bias
eval.bias(agent.LN(-1,2,0,0,5,FALSE)[[1]]) # uncoop sender's bias
eval.bias(agent.LN(-1,2,0,0,5,FALSE)[[2]]) # uncoop receiver's bias
eval.bias(agent.LN(-1,2,0,0,5,TRUE)[[1]]) # coop sender's bias
eval.bias(agent.LN(-1,2,0,0,5,TRUE)[[2]]) # coop receiver's bias
```



## Ratio of params (bias acc vs message cost) and variance kest | k



```{r}
ratio.combs <- data.frame(a = rep(2^(0:5), each=22), 
                          ratio=rep(c(1/seq(2.5,1.25,-0.5),seq(1,10,0.5)),6)) %>%
  mutate(m = a*ratio)

var.decep.df = data.frame()
for(i in 1:nrow(ratio.combs)){
  a = ratio.combs$a[i]
  m = ratio.combs$m[i]
  l = 20
  agent = agent.LN(a,1,-m,2,l)
  s.ksay_k.bias = eval.bias(agent[[1]])
  r.kest_ksay.bias = eval.bias(agent[[2]])
  r.kest_k.bias = eval.bias(agent[[3]])
  r.kest_k.var = eval.kest_k.wvar(agent[[3]])
  r.kest_k.rsq = eval.kest_k.rsq.sim(agent[[3]])
  var.decep.df <- var.decep.df %>%
    bind_rows(
      data.frame(
        a = a,
        m = -m,
        l = l,
        s.ksay_k.bias = s.ksay_k.bias,
        r.kest_ksay.bias = r.kest_ksay.bias,
        r.kest_k.bias = r.kest_k.bias,
        r.kest_k.var = r.kest_k.var,
        r.kest_k.rsq = r.kest_k.rsq
      )
    )
}

decep.df <- var.decep.df %>%
  mutate(neg.m = -m,
         logratio = log10(a/neg.m),
         a_lab = paste("a =",a),
         a_lab = factor(a_lab, levels=c("a = 1",
                                        "a = 2",
                                        "a = 4",
                                        "a = 8",
                                        "a = 16",
                                        "a = 32")))

manual_grid_line <- data.frame(y = seq(-0.5,0.5,0.25))


decep.df_bytype <- decep.df %>%
  gather("bias_type","bias",4:6) %>%
  mutate(bias_type = case_when(bias_type == "s.ksay_k.bias" ~ "sender ksay | k", 
                               bias_type == "r.kest_ksay.bias" ~ "receiver kest | ksay",
                               bias_type == "r.kest_k.bias" ~ "receiver kest | k"),
         bias_type = factor(bias_type, levels=c("sender ksay | k","receiver kest | k","receiver kest | ksay")))


ratio.bias.fig <- decep.df_bytype %>%
  group_by(bias_type, logratio) %>%
  summarise(max_bias = max(bias),
            min_bias = min(bias)) %>%
  ggplot(aes(x=logratio)) +
  geom_rect(aes(xmin=-Inf, xmax=log10(2.5), ymin=-Inf, ymax=0), fill="gray40") +
  geom_segment(data=manual_grid_line, aes(x=-Inf, xend=Inf, y=y, yend=y), colour="gray60") +
  geom_ribbon(aes(ymin=min_bias,  ymax=max_bias, fill=bias_type, colour=bias_type)) +
  geom_text(data=NULL,
            aes(x=0.39, y=0.54, label="sender's bias introduced to message given the truth (ksay - k)"), 
            family="Optima", size=3.5, hjust=1) +
  geom_text(data=NULL,
            aes(x=0.39, y=-0.13, label="judge's accuracy of estimate given the truth (kest - k)"), 
            family="Optima", colour="white", size=3.5, hjust=1) +
  geom_text(data=NULL,
            aes(x=0.39, y=-0.44, label="judge's bias correction to estimate given the message (kest - ksay)"), 
            family="Optima", colour="white", size=3.5, hjust=1) +
  scale_x_continuous("Ratio of Intended Accuracy (a) to Message Cost (m)", 
                     breaks=c(-1,log10(1/5),log10(1/2.5),0,log10(2.5)), 
                     labels=c("1 to 10", "1 to 5", "1 to 2.5", "1 to 1", "2.5 to 1"),
                     expand=c(0,0)) +
  scale_y_continuous("Bias", limits=c(-0.55,0.55), breaks=seq(-0.5,0.5,0.25)) +
  scale_fill_manual(values=c("forestgreen","sandybrown","brown")) +
  scale_colour_manual(values=darken(c("forestgreen","sandybrown","brown"))) +
  guides(fill=FALSE, colour=FALSE) +
  theme_classic() +
  theme(plot.margin = unit(c(0.5,1.5,0.5,0.5), "cm"))



rainb = darken(brewer.pal(6,"Spectral"))
rainb = darken(hue_pal()(6))
ratio.var.fig.graph <- decep.df %>%
  ggplot(aes(x = logratio, y=r.kest_k.rsq^2, colour=a_lab)) +
  geom_line() +
  scale_x_continuous("Ratio of Intended Accuracy (a) to Message Cost (m)", 
                     limits=c(-1, log10(2.5)), # c(-1,1),
                     breaks=c(-1,log10(1/5),log10(1/2.5),0,log10(2.5)), 
                     labels=c("1 to 10", "1 to 5", "1 to 2.5", "1 to 1", "2.5 to 1"),
                     expand=c(0,0)) +
  scale_y_continuous("Correlation in Truth Inference", breaks=seq(0,1,0.2), limits=c(0,1), expand=c(0,0)) +
  scale_colour_manual(values=rainb) +
  guides(colour=F) +
  theme_bw() +
  theme(plot.margin = unit(c(0.5,0.5,0.5,0.6), "cm"))

ratio.var.fig.labels <- ggplot(data=filter(decep.df, round(logratio,8) == round(log10(2.5),8)),
       aes(y=r.kest_k.rsq^2, colour=a_lab)) + 
  geom_text(aes(label=a_lab), x=0,
            family="Optima", size=3, hjust=0) + 
  scale_y_continuous("",limits=c(0,1), expand=c(0,0)) +
  scale_colour_manual(values=rainb) +
  guides(colour=F) +
  theme_void() +
  theme(plot.margin = unit(c(0.5,0,1.4,0), "cm"),
        plot.background = element_rect(fill="white", colour="white"))
ratio.var.fig <- plot_grid(ratio.var.fig.graph, ratio.var.fig.labels, 
                            nrow=1, rel_widths=c(0.95,0.05))
ratio.var.fig

plot_grid(ratio.bias.fig, ratio.var.fig, nrow=2, labels=c("a","b"))
ggsave("img/ratios.png",width=8,height=12)
```








# 2. Do cooperative senders inflate their lies when they suspect the receiver to de-bias messages?

When population is 50% deceptive, 50% cooperative?

```{r}
softmax.param = 40
p.s1.defec.ksay_k = sender(1, 1, -1, 2, p.r0)
p.s1.coop.ksay_k = sender(-1, 2, 0, 0, p.r0)
p.defec = 0.5
p.s1.comb.ksay_k = p.defec*p.s1.defec.ksay_k + (1-p.defec)*p.s1.coop.ksay_k
p.r1.kest_ksay = receiver(p.s1.comb.ksay_k)
p.s2.coop.ksay_k = sender(-1, 2, 0, 0, p.r1.kest_ksay)

fig.s1 <- fig(p.s1.comb.ksay_k, "k", "ksay", "L1 50% Deceptive Sender", role="sender")
fig.r1 <- fig(p.r1.kest_ksay, "ksay", "kest", "L2 Judge", role="receiver") + 
  theme(legend.position="none",
        axis.line = element_line(linetype="dashed"))
fig.s2 <- fig(p.s2.coop.ksay_k, "k", "ksay", "L2 Cooperative Sender", role="sender")
comb50 <- plot_grid(fig.s1, fig.r1, fig.s2, legend,
                      nrow=3, rel_heights=c(0.3,0.3,0.3,0.1))
#ggsave(paste0("img/defec",p.defec*100,".png"), width=8, height=5.5)
```

```{r warning=FALSE}
softmax.param = 40
sender.label.size = 4.5
p.r0 = r.0()
p.s1.defec.ksay_k = sender(1, 1, -1, 2, p.r0)
p.s1.coop.ksay_k = sender(-1, 2, 0, 0, p.r0)
fig.pDefec <- list()
ps = c(0,0.1,0.25,0.4,0.5,0.75,1)

for(i in 1:length(ps)){
  fig.pDefec[[i]] <- local({
    p.defec = ps[i]
    p.s1.comb.ksay_k = p.defec*p.s1.defec.ksay_k + (1-p.defec)*p.s1.coop.ksay_k
    p.r1.kest_ksay = receiver(p.s1.comb.ksay_k)
    p.s2.coop.ksay_k = sender(-1, 2, 0, 0, p.r1.kest_ksay)
    
    label1 <- ggplot() + 
      annotate("text", label=paste0(100*p.defec,"% Deceptive L1"), 
               x=1, y=1, hjust=0.5, size=sender.label.size) + 
      theme_void()
    label2 <- ggplot() + 
      annotate("text", label="Cooperative L2", 
               x=1, y=1, hjust=0.5, size=sender.label.size) + 
      theme_void()
    fig.r0 <- fig(p.r0, "ksay", "kest", role="receiver") + 
      theme(legend.position="none", 
            plot.title=element_blank(),
            axis.line = element_line(linetype="dashed"))
    fig.s1 <- fig(p.s1.comb.ksay_k, "k", "ksay", role="sender") +
      theme(plot.title=element_blank())
    fig.r1 <- fig(p.r1.kest_ksay, role="receiver") + 
      theme(legend.position="none",
            plot.title=element_blank(),
            axis.line = element_line(linetype="dashed"))
    fig.s2 <- fig(p.s2.coop.ksay_k, role="sender") +
      theme(plot.title=element_blank())
    fig.full <- plot_grid(NULL, NULL,fig.r0, 
                          label1, fig.s1, fig.r1, 
                          label2, fig.s2,
                          nrow=3, byrow = FALSE, rel_heights=c(0.12,0.44,0.44))
    #ggsave(paste0("img/defec",p.defec*100,".pdf"), fig.full, width=8, height=5.5)
    print(fig.full)
  })
}
```

```{r}
# also plot when L2 deceiver
p.defec = 1
p.s1.comb.ksay_k = p.defec*p.s1.defec.ksay_k + (1-p.defec)*p.s1.coop.ksay_k
p.r1.kest_ksay = receiver(p.s1.comb.ksay_k)
p.s2.coop.ksay_k = sender(1, 1, -1, 2, p.r1.kest_ksay)

label1 <- ggplot() + 
  annotate("text", label=paste0(100*p.defec,"% Deceptive L1"), 
           x=1, y=1, hjust=0.5, size=sender.label.size) + 
  theme_void()
label2 <- ggplot() + 
  annotate("text", label="Deceptive L2", 
           x=1, y=1, hjust=0.5, size=sender.label.size) + 
  theme_void()
fig.r0 <- fig(p.r0, "ksay", "kest", role="receiver") + 
  theme(legend.position="none", 
        plot.title=element_blank(),
        axis.line = element_line(linetype="dashed"))
fig.s1 <- fig(p.s1.comb.ksay_k, "k", "ksay", role="sender") +
  theme(plot.title=element_blank())
fig.r1 <- fig(p.r1.kest_ksay, role="receiver") + 
  theme(legend.position="none",
        plot.title=element_blank(),
        axis.line = element_line(linetype="dashed"))
fig.s2 <- fig(p.s2.coop.ksay_k, role="sender") +
  theme(plot.title=element_blank())
fig.full_defec <- plot_grid(NULL, NULL,fig.r0, 
                      label1, fig.s1, fig.r1, 
                      label2, fig.s2,
                      nrow=3, byrow = FALSE, rel_heights=c(0.12,0.44,0.44))
ggsave(paste0("img/defec",p.defec*100,"_defec.pdf"), fig.full_defec, width=8, height=5.5)
```

```{r}
pDefec.df <- data.frame()

p.r0 = r.0()
p.s1.defec.ksay_k = sender(1, 1, -1, 2, p.r0)
p.s1.coop.ksay_k = sender(-1, 2, 0, 0, p.r0)
for(p.defec in seq(0,1,0.005)){
  p.s1.comb.ksay_k = p.defec*p.s1.defec.ksay_k + (1-p.defec)*p.s1.coop.ksay_k
  p.r1.kest_ksay = receiver(p.s1.comb.ksay_k)
  p.s2.coop.ksay_k = sender(-1, 2, 0, 0, p.r1.kest_ksay)
  pDefec.df <- pDefec.df %>%
    bind_rows(
      data.frame(
        pDefec = p.defec,
        biasS2 = eval.bias(p.s2.coop.ksay_k)
      )
  )
}


pDefec.defec.df <- data.frame(pDefec = 1,
                              biasS2 = eval.bias(agent.LN(1,1,-1,2,2)[[1]]),
                              goal = "defec")

arrowVals = pDefec.df %>%
  filter(pDefec %in% c(0,0.5,1)) %>%
  mutate(goal = "coop") %>%
  bind_rows(pDefec.defec.df) %>%
  mutate(goalColor = paste0(goal,"_",pDefec))

logit <- function(p){
  log(p/(1-p))
}



pDefec.df %>%
  filter(pDefec == 1)

fig.pDefecSumm <- ggplot(pDefec.df, aes(x=pDefec, y=biasS2)) +
  # geom_segment(data=arrowVals,
  #              aes(x = pDefec, y = biasS2, xend = 1.05, yend = biasS2, colour=goalColor),
  #              arrow = arrow(length = unit(0.5, "cm")),
  #              size=1.1) +
  scale_colour_manual(values=c("gray80","gray40","black","red")) +
  guides(colour=FALSE) +
  geom_point(size=2.5) +
  geom_point(data=pDefec.defec.df, 
             aes(x=pDefec,y=biasS2),
             colour="red", size=3.5, shape=18) +
  scale_x_continuous("Proportion of Deceivers in Population",
                     limits=c(0,1.05), expand=c(0,0,0,0)) +
  scale_y_continuous("Bias of L2 Cooperative Sender") +
  theme_minimal() +
  theme(axis.title=element_text(size=18),
        axis.text=element_text(size=16))
#ggsave("img/defecSumm.pdf", fig.pDefecSumm, width=6, height=6)
```

```{r}
m = 0.1
defec.0 <- fig.pDefec[[1]] + 
  theme(plot.margin = unit(c(m,m,0.08,m), "cm"),
        plot.background  = element_rect(colour = "gray80", size=2))
defec.50 <- fig.pDefec[[5]] + 
  theme(plot.margin = unit(c(m,m,0.08,m), "cm"),
        plot.background = element_rect(colour = "gray40", size=2))
defec.100 <- fig.pDefec[[7]] + 
  theme(plot.margin = unit(c(m,m,0.08,m), "cm"),
        plot.background = element_rect(colour = "black", size=2))
defec.100.defec <- fig.full_defec +
  theme(plot.margin = unit(c(m,m,0.08,m), "cm"),
        plot.background = element_rect(colour = "red", size=2))

defec.props <- plot_grid(defec.100.defec,
                         NULL,defec.100, 
                         NULL,defec.50, 
                         NULL,defec.0, 
              nrow=7, rel_heights=c(1,0.05,1,0.05,1,0.05,1))
plot_grid(fig.pDefecSumm + theme(plot.margin=unit(c(2,0,0.7,0.5),"cm")), 
          defec.props, 
          #labels=c("a","b"), label_size=24,
          ncol=2, rel_widths=c(0.6,0.4))
ggsave("img/defecSumm.pdf", width=12, height=10)
```